#use-added-syntax(esir)
defpackage ocdb/generator-utils:
  import core
  import collections
  import math
  import esir
  import esir/utils
  import esir/gen
  import esir/fonts
  import esir/repl-lib
  import ocdb/tests/default-harness

  import ocdb/checks
  import ocdb/bundles
  import ocdb/pinspec
  import ocdb/land-patterns
  import ocdb/generic-components
  import ocdb/calculate-connected

  import jitpcb/powergen
  import jitpcb/powergen/gen

  import ocdb/design-vars

  import jitpcb/visualizer
  import ocdb/rules
  import ocdb/stackups
  import ocdb/symbols
  import ocdb/box-symbol

; =======================================
; Ciruit convenience functions
; =======================================

; Add load balancing caps to crystal oscillator
public defn add-xtal-caps (xtal:Ref, gnd:Ref, stray-capacitance:Double) :
  inside pcb-module:
    val c-load = property(xtal.load-capacitance)
    val c-bal = 2.0 * (c-load - stray-capacitance)
    cap-strap(xtal.p[1], gnd, c-bal)
    val c = cap-strap(xtal.p[2], gnd, c-bal)
    c 
; Default stray capacitance assumed 5pf. 
public defn add-xtal-caps (xtal:Ref, gnd:Ref) :
  add-xtal-caps(xtal, gnd, 5.0e-12)

; Add pullup resistors to an open-drain bus (like i2c) to vio pin. Specced for minimum power draw meeting speed requirements [TI app note:slva689].
public defn add-open-drain-pullups (bus:Ref, vio:Ref, clk-rate:Double, bus-capacitance:Double) :
  inside pcb-module:
    val rise-time = 0.35 / (clk-rate * 5.0) ; Signal bandwidth~ 5x clock rate for fairly sharp edge
    val r = closest-std-val(rise-time / (0.8473 * bus-capacitance), 5.0)
    for p in ports(bus) do :
      res-strap(p, vio, r)

; Default is 100kHz clock rate, 100pF bus capacitance.
public defn add-open-drain-pullups (bus:Ref, vio:Ref) :
  add-open-drain-pullups(bus, vio, 100.0e3, 100.0e-12)

; =======================================
; Piecewise linear functions
; Example call : PWL([[x0 y0] [x1 y1] ... [xn yn])[x]. Returns interpolated value of y at x
; =======================================
public deftype PWL
public defmulti get (f:PWL, x:Double) -> Double
public defn PWL (ps:Tuple<[Double,Double]>) -> PWL :
  new PWL :
    defmethod get (this, x:Double) :
      val n = length(ps)
      if x < ps[0][0] :
        ; println("Warning: PWL is extrapolating with zero-order hold")
        ps[0][1]
      else if x >= ps[0][0] and x <= ps[n - 1][0] :
        val i = for i in 0 to n find! :
          ps[i][0] >= x
        val j = for i in reverse(0 to n) find! :
          ps[i][0] <= x
        if i == j :
          ps[i][1]
        else :
          val dydx = (ps[i][1] - ps[j][1]) / (ps[i][0] - ps[j][0])
          dydx * (x - ps[j][0]) + ps[j][1]
      else if x > ps[n - 1][0] :
        ; println("Warning: PWL is extrapolating with zero-order hold")
        ps[n - 1][1]
      else  :
        fatal("Something is wrong in PWL with x = %_" % [x])

; =======================================
; Assign schematic and layout groups
; =======================================
public defn group-modules (mods:Tuple<Tuple<Ref>>) :
  inside pcb-module :
    val g-count = to-seq(0 to false)  
    for m in mods do :
      val g-name = Ref("g-sg-%_" % [next(g-count)])
      for r in m do :
        schematic-group({r}) = {g-name}
        layout-group({r}) = {g-name}

; =======================================
; This function is used to create a package mapping and box symbol from PinSpec
; =======================================
public defn gen-symbol-map (ps:PinSpec, pkg:Ref) :
  inside pcb-component :
    make-pins(ps)
    assign-package(pkg, ps)
    make-box-symbol(ps)

; =======================================
; Convience functions to add standard pin properties
; =======================================
public defn apply-voltage-rating-params (rated-voltage:[Double, Double]) :
  inside properties:
    rated-voltage => rated-voltage

public defn apply-power-pin-params (vdd:Double) :
  inside properties:
    power-pin => true
    vdd => vdd

public defn apply-power-supply-pin-params (vdd:Double, max-current:Double) :
  inside properties:
    power-pin => true
    supply-pin => true
    vdd => vdd
    max-current => vdd

public defn apply-digital-io-params (vil:Double vih:Double vol:Double voh:Double) :
  inside properties:
    digital-io => true
    type => "io"
    vil => vil
    vih => vih
    vol => vol
    voh => voh

public defn apply-digital-input-params (vil:Double vih:Double) :
  inside properties:
    digital-io => true
    type => "i"
    vil => vil
    vih => vih

public defn apply-enable-pin-params (enable:Ref) :
  inside properties:
    digital-io => true
    type => "i"
    enable-pin => true
    active-ref => enable

public defn apply-digital-output-params (vil:Double vih:Double) :
  inside properties:
    digital-io => true
    type => "o"
    vil => vil
    vih => vih 

public defn apply-lvds-params (vol:Double, voh:Double, vo-diff:[Double,Double,Double] vo-cm:[Double,Double,Double] vi-diff:[Double,Double,Double] vi-cm:[Double,Double,Double]) :
  inside properties:
    lvds => true
    voh => voh 
    vol => vol 
    vo-diff => vo-diff 
    vo-cm   => vo-cm   
    vi-diff => vi-diff 
    vi-cm   => vi-cm   


;================
; Check utilities
;================
; User defined pass that gets run at end of design pipeline
public pcb-check final-pass ():
  ; println("Final pass")
  defn propogate-voltage (n:NetStmt) :
    val supply-pin  = for p in refs(n) find : has-property?(p.voltage)
    if supply-pin is Ref :
      val sp = supply-pin as Ref
      if has-property?(sp.voltage) : 
        val v = property(sp.voltage)
        for p in refs(n) do :
          if has-property?(p.supply-pin) :
            if property(p.voltage) != v :
              println("Incompatible supply voltages on same net.")
          else :
            inside pcb-module:
              properties({p}):
                voltage => v
  for n in nets(self) do :
    propogate-voltage(n)

public defn check-design () :
  inside pcb-module:
    ; check final-pass()

    for (instance in all-component-instances(self)) do :
      properties({instance}):
        temperature => OPERATING-TEMPERATURE
      ; Check components
      if has-property?(instance.resistor) :
        check resistor-check(instance)
      if has-property?(instance.capacitor) :
        check capacitor-check(instance)

    check enable-pins()
    check io()

public defn check-oscillator (o:Ref, intf:Ref, load-cap:Ref) :
  inside pcb-module:
    check oscillator-check-frequency(o, intf)
    check oscillator-check-gain(o, intf, load-cap)
    check oscillator-check-drive(o, intf, load-cap)
    check oscillator-check-pullability(o, intf, load-cap)

public pcb-check enable-pins ():
  inside pcb-module :
    for i in all-component-instances(self) do :
      for p in all-pins(i) do :
        if has-property?(p.enable-pin) :
          #CHECK(connected?(p))

public defn default-enable ():
  inside pcb-module :
    for i in all-component-instances(self) do :
      for p in all-pins(i) do :
        if has-property?(p.enable-pin) :
          println("Wiring %_ to %_ for enable." % [p property(p.active-ref)])
          net ({p} {i}.{property(p.active-ref)})

public defn connect-floating-inputs-to-gnd ():
  inside pcb-module :
    for i in all-component-instances(self) do :
      for p in all-pins(i) do :
        ; println("Is %_ connected? %_" % [p, connected?(p)])
        if not connected?(p) and
           has-property?(p.digital-io) and
           property(p.type) == "i" :
          println("Connecting floating input %_ to gnd." % [p])
          net ({p}, gnd)

; =======================================
; Attach the power generator to designs and loads.
; =======================================
public defn generate-power () :
  println("JITPCB: Generating power system.")
  inside pcb-module :
    for i in all-component-instances(self) do :
      for p in all-pins(i) do :
        if has-property?(p.power-request) :
          val [v a n] = property(p.power-request)
          within (rail) = make-load("Load", v, a, n) :
            net ({p}, {pos(rail)})
            net ({i}.{property(p.gnd-ref)}, {neg(rail)})

    for i in all-component-instances(self) do :
      for p in all-pins(i) do :
        if has-property?(p.power-input) :
          generate-power-system(property(p.power-input), OPERATING-TEMPERATURE[1], p, property(p.gnd-ref))

public defn set-power-source (pos:Ref, neg:Ref, v-in:Double):
  inside pcb-module:
    properties({pos}):
      power-input => v-in
      gnd-ref => #R({neg})
