#use-added-syntax(esir)
defpackage ocdb/db-parts :
  import core
  import collections
  import json
  import math
  import esir with :
    prefix(Resistor) => EModel-
    prefix(Capacitor) => EModel-
    prefix(Inductor) => EModel-
  import esir/utils
  import esir/gen
  import esir/repl-lib
  import ocdb/tests/default-harness

  import ocdb/land-patterns
  import ocdb/generator-utils
  import ocdb/symbols
  import ocdb/design-vars


deftype Component
public defmulti x (component: Component) -> Double
public defmulti y (component: Component) -> Double
public defmulti area (component: Component) -> Double
public defmulti to-esir (component: Component) -> VarRef
public defmulti generate-esir (component: Component) -> VarRef

defmethod area (component: Component) -> Double :
  x(component) * y(component)

defmethod generate-esir (cmp: Component) -> VarRef :
  val esir-cmp = to-esir(cmp)
  ensure-generated(esir-cmp)

  esir-cmp

;============================================================
;====================== Resistor ============================
;============================================================

public defstruct Resistor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  case: String|False
  extra: Tuple<KeyValue>
  ; Resistor specific properties
  type: String ; Type of resistor
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacture (Ohm/Ohm)
  resistance: Double ; Nominal resistance (Ohm)
  composition: String|False ; Composition of resistor
  rated-power: Double|False ; Power dissipation limit as rated by manufacturer. One value, or PWL function (W | [degC, W])
  TCR: TCR|False ; Temperature coefficient of resistance (ohms/ohm*degC)

public defn Resistor (json: JObject) -> Resistor :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Resistor(json["manufacturer"] as String,
           json["mpn"] as String,
           json["trust"] as String,
           x,
           y,
           z,
           json["mounting"] as String,
           parse-rated-temperature(json),
           optional-string(json, "case"),
           entries(json["extra"] as JObject),
           ; Resistor specific properties
           json["type"] as String,  ; FIXME: remove type because it is redundant with mounting ? It is not pot, photo...
           parse-tolerance(json),
           json["resistance"] as Double,
           optional-string(json, "composition"),
           optional-double(json, "rated-power"),
           resistance-tcr(json))

defn resistance-tcr (json: JObject) -> TCR|False :
  val tcr-json = get?(json, "tcr")
  match(tcr-json) :
    (tcr: Double) :
      TCR(tcr, tcr)
    (object: JObject) :
      TCR(object["pos"] as Double, object["neg"] as Double)
    (f: False) :
      false

public defstruct TCR :
  positive: Double
  negative: Double

defmethod to-esir (resistor: Resistor) -> VarRef :
  unique pcb-component my-resistor :
    val manufacturer-string = manufacturer(resistor)
    match(manufacturer-string: String) :
      manufacturer = manufacturer-string

    mpn = mpn(resistor)

    val description-string = lookup?(extra(resistor), "description")
    match(description-string: String) :
      description = description-string

    port p : pin[{1 2}]
    symbol = {resistor-sym(false)}(p[1] => p[1], p[2] => p[2])
    val case = case(resistor)
    match(case: String) :
      if all?(digit?, to-seq(case)) :
        package = {ipc-two-pin-package(case)}(p[1] => p[1], p[2] => p[2])
      else :  ; example: case = "Axial"
        package = {dummy-package(2, [x(resistor) y(resistor)])}(p[1] => p[1], p[2] => p[2])
    else :
      package = {dummy-package(2, [x(resistor) y(resistor)])}(p[1] => p[1], p[2] => p[2])

    emodel = EModel-Resistor(resistance(resistor),
                             max-or-unknown(tolerance(resistor)),
                             double-or-unknown(rated-power(resistor)))
    reference-prefix = "R"
    val TCR = TCR(resistor)
    val rated-temperature = rated-temperature(resistor)
    properties :
      resistor => true
      trust => trust(resistor)
      x => x(resistor)
      y => y(resistor)
      z => z(resistor)
      mounting => mounting(resistor)
      match(rated-temperature: MinMaxRange): rated-temperature => [min(rated-temperature), max(rated-temperature)]
      case => /case(resistor)
      extra => extra(resistor)
      type => type(resistor)
      tolerance => tolerance(resistor)
      resistance => resistance(resistor)
      composition => composition(resistor)  ; this is the type => "thick-film" in gen-res-cmp
      rated-power => /rated-power(resistor)
      match(TCR: TCR): TCR => [positive(TCR), negative(TCR)]
    spice :
      "[R] {p[1]} {p[2]} {resistance(resistor)}"

  my-resistor

public defn Resistor (properties:Tuple<KeyValue>) -> Resistor :
  Resistor(properties, ["tolerance", "tcr"])

public defn Resistor (properties:Tuple<KeyValue>, exist:Tuple<String>) -> Resistor :
    ;Query the database with the given properties
    val query-properties = to-tuple $ cat([
      "category" => "resistor",
      "_optimize_for" => OPTIMIZE-FOR,
      "_exist" => exist
    ], properties)

    Resistor(dbquery-first(query-properties))

;============================================================
;===================== Capacitor ============================
;============================================================

defstruct Capacitor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  case: String|False
  extra: Tuple<KeyValue>
  ; Capacitor specific properties
  type: String ; Type of resistor [“ceramic”, “film”, “electrolytic]
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacturer (Farad/Farad)
  capacitance: Double ; Nominal capacitance (Farad)
  anode: String|False ; Anode material of electrolytic capacitor [“aluminum”, “tantalum”, “niobium-oxide”]
  electrolyte: String|False ; Electrolyte material of electrolytic capacitor [“polymer”, “manganese-dioxide”, “hybrid”, “non-solid”]
  temperature-coefficient: String|False ; Temperature coefficient code of capacitance [“X7R”, ...]
  esr: Double|False
  rated-voltage: Double|False ; Maximum voltage rating from manufacturer (Volts)
  rated-current-pk: Double|False ; Maximum peak current rating from manufacturer (Amperes)
  rated-current-rms: Double|False ; Maximum rms current rating from manufacturer (Amperes)

public defn Capacitor (json: JObject) -> Capacitor :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Capacitor(json["manufacturer"] as String,
            json["mpn"] as String,
            json["trust"] as String,
            x,
            y,
            z,
            json["mounting"] as String,
            parse-rated-temperature(json),
            optional-string(json, "case"),
            entries(json["extra"] as JObject),
            ; Resistor specific properties
            json["type"] as String,
            parse-tolerance(json),
            json["capacitance"] as Double,
            optional-string(json, "anode"),
            optional-string(json, "electrolyte"),
            capacitor-temperature-coefficient(json),
            optional-double(json, "esr"),
            optional-double(json, "rated-voltage"),
            optional-double(json, "rated-current-pk"),
            optional-double(json, "rated-current-rms"))

defn capacitor-temperature-coefficient (json: JObject) -> String|False :
  val temperature-coefficient-json = get?(json, "temperature-coefficient")
  match(temperature-coefficient-json: JObject) :
    temperature-coefficient-json["code"] as String

defmethod to-esir (capacitor: Capacitor) -> VarRef:
  unique pcb-component my-capacitor :
    val manufacturer-string = manufacturer(capacitor)
    match(manufacturer-string: String) :
      manufacturer = manufacturer-string

    mpn = mpn(capacitor)

    val description-string = lookup?(extra(capacitor), "description")
    match(description-string: String) :
      description = description-string

    val type-string = type(capacitor)
    val pol? = not (type-string == "ceramic" or type-string == "film")
    port p : pin[{1 2}]
    symbol = {capacitor-sym(pol?)}(p[1] => p[1], p[2] => p[2])
    val case = case(capacitor)
    match(case: String) :
      if all?(digit?, to-seq(case)) :
        package = {ipc-two-pin-package(case)}(p[1] => p[1], p[2] => p[2])
      else :
        package = {dummy-package(2, [x(capacitor) y(capacitor)])}(p[1] => p[1], p[2] => p[2])
    else :
      package = {dummy-package(2, [x(capacitor) y(capacitor)])}(p[1] => p[1], p[2] => p[2])

    emodel = EModel-Capacitor(capacitance(capacitor),
                             max-or-unknown(tolerance(capacitor)),
                             double-or-unknown(rated-voltage(capacitor)),
                             pol?,
                             UNKNOWN, ; FIXME: define low-esr? as below a certain threshold on the esr ?
                             string-or-unknown(temperature-coefficient(capacitor)),
                             UNKNOWN) ; FIXME: find out the dielectric information (look at type and anode?)
    reference-prefix = "C"
    val rated-temperature = rated-temperature(capacitor)
    val esr = esr(capacitor)
    val capacitance = capacitance(capacitor)
    properties :
      capacitor => true
      trust => trust(capacitor)
      x => x(capacitor)
      y => y(capacitor)
      z => z(capacitor)
      mounting => mounting(capacitor)
      match(rated-temperature: MinMaxRange): rated-temperature => [min(rated-temperature), max(rated-temperature)]
      case => /case(capacitor)
      extra => extra(capacitor)
      type => type(capacitor)
      tolerance => tolerance(capacitor)
      capacitance => capacitance
      anode => anode(capacitor)
      electrolyte => electrolyte(capacitor)
      temperature-coefficient => temperature-coefficient(capacitor)
      esr => esr
      rated-voltage => /rated-voltage(capacitor)
      rated-current-pk => rated-current-pk(capacitor)
      rated-current-rms => rated-current-rms(capacitor)

    match(esr: Double) :
      spice :
        "[C] {p[1]} tmp {capacitance}"
        "[R] tmp {p[2]} {esr}"
    else :
      spice :
        "[C] {p[1]} tmp {capacitance}"


  my-capacitor

public defn Capacitor (properties:Tuple<KeyValue>) -> Capacitor :
  Capacitor(properties, ["tolerance", "esr"])

public defn Capacitor (properties:Tuple<KeyValue>, exist:Tuple<String>) -> Capacitor :
    ;Query the database with the given properties
    val query-properties = to-tuple $ cat([
      "category" => "capacitor",
      "_optimize_for" => OPTIMIZE-FOR
      "_exist" => exist
    ], properties)

    Capacitor(dbquery-first(query-properties))

;============================================================
;====================== Inductor ============================
;============================================================

defstruct Inductor <: Component :
  ; Generic properties
  manufacturer: String
  mpn: String
  trust: String
  x: Double with: (as-method => true)
  y: Double with: (as-method => true)
  z: Double|False
  mounting: String
  rated-temperature: MinMaxRange|False
  case: String|False
  extra: Tuple<KeyValue>
  ; Inductor specific properties
  type: String ; Type of resistor [“wirewound”, “thick film”, ...]
  tolerance: MinMaxRange|False ; Guaranteed tolerance from manufacture (Henry/Henry)
  inductance: Double ; Nominal inductance (Henry)
  material-core: String|False ; Composition of inductor [“ceramic”, “Ferrite”, ...]
  shielding: String|False ; Magnetic field status [“semi-shielded”, “shielded”, “unshielded”]
  current-rating: Double|False ; Maximum steady-state current rating from manufacture (Amperes)
  current-saturation: Double|False ; Percentage inductance drop (typ 20-30%) at peak currents (Amperes)
  dc-resistance: Double|False ; Nominal resistance (Ohm)
  quality-factor: Double|False ; Loss factor inverse - ratio between inductors resistance and inductance (ratio@freq)
  self-resonant-frequency: Double|False ; Frequency at which inductor impedance becomes very high / open circuit (freq in Hz)

public defn Inductor (json: JObject) -> Inductor :
  val [x, y, z] = parse-dimensions(json["dimensions"] as JObject)

  Inductor(json["manufacturer"] as String,
           json["mpn"] as String,
           json["trust"] as String,
           x,
           y,
           z,
           json["mounting"] as String,
           parse-rated-temperature(json),
           optional-string(json, "case"),
           entries(json["extra"] as JObject),
           ; Resistor specific properties
           json["type"] as String,
           parse-tolerance(json),
           json["inductance"] as Double,
           optional-string(json, "material-core"),
           optional-string(json, "shielding"),
           optional-double(json, "current-rating"),
           optional-double(json, "current-saturation"),
           optional-double(json, "dc-resistance"),
           optional-double(json, "quality-factor"),
           optional-double(json, "self-resonant-frequency"))

defmethod to-esir (inductor: Inductor) -> VarRef :
  unique pcb-component my-inductor :
    val manufacturer-string = manufacturer(inductor)
    match(manufacturer-string: String) :
      manufacturer = manufacturer-string

    mpn = mpn(inductor)

    val description-string = lookup?(extra(inductor), "description")
    match(description-string: String) :
      description = description-string

    port p : pin[{1 2}]
    symbol = inductor-sym(p[1] => p[1], p[2] => p[2])
    val case = case(inductor)
    match(case: String) :
      if all?(digit?, to-seq(case)) :
        package = {ipc-two-pin-package(case)}(p[1] => p[1], p[2] => p[2])
      else :  ; example: case = "Axial"
        package = {dummy-package(2, [x(inductor) y(inductor)])}(p[1] => p[1], p[2] => p[2])
    else :
      package = {dummy-package(2, [x(inductor) y(inductor)])}(p[1] => p[1], p[2] => p[2])

    val inductance = inductance(inductor)
    emodel = EModel-Inductor(inductance,
                             max-or-unknown(tolerance(inductor)),
                             double-or-unknown(current-rating(inductor)))
    reference-prefix = "L"
    val rated-temperature = rated-temperature(inductor)
    properties :
      inductor => true
      trust => trust(inductor)
      x => x(inductor)
      y => y(inductor)
      z => z(inductor)
      mounting => mounting(inductor)
      match(rated-temperature: MinMaxRange): rated-temperature => [min(rated-temperature), max(rated-temperature)]
      case => /case(inductor)
      extra => extra(inductor)
      type => type(inductor)
      tolerance => tolerance(inductor)
      inductance => inductance
      material-core => material-core(inductor)
      shielding => shielding(inductor)
      current-rating => current-rating(inductor)
      current-saturation => current-saturation(inductor)
      dc-resistance => dc-resistance(inductor)
      quality-factor => quality-factor(inductor)
      self-resonant-frequency => self-resonant-frequency(inductor)
    spice :
      "[L] {p[1]} {p[2]} {inductance}"

  my-inductor

public defn Inductor (properties:Tuple<KeyValue>) -> Inductor :
  Inductor(properties, ["tolerance"])

public defn Inductor (properties:Tuple<KeyValue>, exist:Tuple<String>) -> Inductor :
    val query-properties = to-tuple $ cat([
      "category" => "inductor",
      "_optimize_for" => OPTIMIZE-FOR,
      "_exist" => exist
    ], properties)

    Inductor(dbquery-first(query-properties))

;============================================================
;====================== Printer =============================
;============================================================

defmethod print (o:OutputStream, r:Resistor) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "resistance = %_" % [resistance(r)]
    "composition = %_" % [composition(r)]
    "rated-power = %_" % [rated-power(r)]
    "TCR = %_" % [TCR(r)]
    "extra = %_" % [indented-list(extra(r))]]
  print(o, "Resistor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:Capacitor) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "capacitance = %_" % [capacitance(r)]
    "anode = %_" % [anode(r)]
    "electrolyte = %_" % [electrolyte(r)]
    "temperature-coefficient = %_" % [temperature-coefficient(r)]
    "esr = %_" % [esr(r)]
    "rated-voltage = %_" % [rated-voltage(r)]
    "rated-current-pk = %_" % [rated-current-pk(r)]
    "rated-current-rms = %_" % [rated-current-rms(r)]
    "extra = %_" % [indented-list(extra(r))]]
  print(o, "Capacitor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:Inductor) :
  val items = [
    "mpn = %_" % [mpn(r)]
    "trust = %_" % [trust(r)]
    "(x, y, z) = (%,)" % [[x(r), y(r), z(r)]]
    "mounting = %_" % [mounting(r)]
    "rated-temperature = %_" % [rated-temperature(r)]
    "case = %_" % [case(r)]
    "type = %_" % [type(r)]
    "tolerance = %_" % [tolerance(r)]
    "inductance = %_" % [inductance(r)]
    "material-core = %_" % [material-core(r)]
    "shielding = %_" % [shielding(r)]
    "current-rating = %_" % [current-rating(r)]
    "current-saturation = %_" % [current-saturation(r)]
    "dc-resistance = %_" % [dc-resistance(r)]
    "quality-factor = %_" % [quality-factor(r)]
    "self-resonant-frequency = %_" % [self-resonant-frequency(r)]
    "extra = %_" % [indented-list(extra(r))]]
  print(o, "Inductor(%_)" % [indented-list(items)])

defmethod print (o:OutputStream, r:MinMaxRange) :
  print(o, "MinMaxRange(min=%_, max=%_)" % [min(r), max(r)])

defmethod print (o:OutputStream, r:TCR) :
  print(o, "TCR(positive=%_, negative=%_)" % [positive(r), negative(r)])

defn indented-list (items:Seqable) :
  new Printable :
    defmethod print (o:OutputStream, this) :
      val o2 = IndentedStream(o)
      do(lnprint{o2, _}, items)

;============================================================
;=================== Parsing utils ==========================
;============================================================

defn parse-dimensions (dimensions: JObject) -> [Double, Double, Double|False] :
  [dimensions["x"] as Double, dimensions["y"] as Double, optional-double(dimensions, "z")]

defn optional-string (json: JObject, field: String) -> String|False :
  val j = get?(json, field)
  j as String when not (j is False or j is JNull)

defn optional-double (json: JObject, field: String) -> Double|False :
  val j = get?(json, field)
  j as Double when not (j is False or j is JNull)

public defstruct MinMaxRange :
  min: Double
  max: Double

defn parse-rated-temperature (json: JObject) -> MinMaxRange|False :
  val rated-temperature-json = get?(json, "rated-temperature")
  match(rated-temperature-json: [Double, Double]) :
    MinMaxRange(rated-temperature-json[0], rated-temperature-json[1])

defn parse-tolerance (json: JObject) -> MinMaxRange|False :
  val tolerance-json = get?(json, "tolerance")
  match(tolerance-json):
    (minmax: JObject) :
      MinMaxRange(minmax["min"] as Double, minmax["max"] as Double)
    (tol: Double) :
      MinMaxRange((- tol), tol)

defn max-or-unknown (value: MinMaxRange|False) -> Double|UNKNOWN :  ; FIXME: Tolerance minmax range not handled properly but emodel is going depricated
  match(value: MinMaxRange) :
    max(value)
  else:
    UNKNOWN

defn double-or-unknown (value: Double|False) :
  match(value: Double) :
    value
  else:
    UNKNOWN

defn string-or-unknown (value: String|False) :
  match(value: String) :
    value
  else:
    UNKNOWN
