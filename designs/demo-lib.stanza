#use-added-syntax(esir)
defpackage demo-lib:
  import core
  import collections
  import math
  import esir
  import esir/utils
  import esir/gen
  import esir/fonts
  import repl-lib
  import tests/default-harness

  import bundles
  import pinspec
  import land-patterns
  import generic-components

  import env-params



public pcb-component example-resistor :
  manufacturer = "Yageo"
  mpn = "RC0402FR-071KL"
  description = "RES SMD 1K OHM 1% 1/16W 0402"

  port p : pin[{1 2}]
  package = {ipc-two-pin-package("0402")}(p[1] => p[1], p[2] => p[2])
  reference-prefix = "R"









public defn make-voltage-regulator (input:Ref, v-out:[Double Double Double]|Double, reg:Ref) -> [Ref, Ref] :
  inside pcb-module :
    val vin = property(input.voltage)
    unique inst vrm : {reg}
    net ({input}, {vrm}.vin)
    properties({vrm}.vout):
      voltage => v-out
    [vrm.vout, vrm.en]

public defn make-board-controller (rails:Tuple<Ref>) :
  inside pcb-module :
    val vm = make-voltage-monitor(rails)
    unique inst board-controller : board-controller

    val n = length(rails)
    require mon:gpio[n] from {board-controller}
    for i in 0 to n do : net (mon[i].gpio, {vm}.out[i])

    board-controller

public pcb-module voltage-monitor (rail-voltages:Tuple<[Double,Double,Double]>) :
  port src : power 
  val n = length(rail-voltages)
  port out : pin[n]
  port rails : pin[n]

  ; Each monitor has 6 ports so create enough of them
  var num-mon = (n + 6 - 1) / 6

  ; Instatiate a group of MAX1606X voltage monitors
  inst mon : maxim-max1606x-cmp[num-mon]

  for i in 0 to n do :
    properties(rails[i]):
      voltage => rail-voltages[i]
    val [chip-idx, chip-ref, mon-idx] = [i / 6, mon[i / 6], i % 6]

  ; Divide input to match voltage of MAX16061E
    passive-circuits/make-voltage-divider(rails[i], chip-ref.in[mon-idx], src.gnd, [0.3 0.373 0.4], 1.0e-3)

    net (out[i], {chip-ref}.out[mon-idx])
    net (src.gnd, {chip-ref}.GND, {chip-ref}.PAD, {chip-ref}.TOL)
    net (src.vdd, {chip-ref}.VCC)

public defn make-voltage-monitor (rails:Tuple<Ref>):
  inside pcb-module :
    ; Extract voltage property to tuple of voltages.
    val rail-voltages = for r in rails map :
      property(r.voltage)
    unique inst voltage-monitor : {voltage-monitor(rail-voltages)}
    val n = length(rails)
    for i in 0 to n do :
      net ({voltage-monitor}.rails[i], {rails}[i])
    voltage-monitor

public pcb-connection isolate (a:Ref, b:Ref) :
  unique inst buf : {texas-instruments/ISO1540}
  net ({a}.sda, {buf}.SDA1)
  net ({a}.scl, {buf}.SCL1)
  net ({b}.sda, {buf}.SDA2)
  net ({b}.scl, {buf}.SCL2)
when :
  port-type(a) == #PT(i2c) and
  port-type(b) == #PT(i2c) 

public pcb-design VITA57-1-FMC-single (main-module:Ref) :
  unique pcb-module temp-module :
    inst instance : {main-module}
    package(instance) at loc(0.0, 0.0) on Top
    package(instance.fmc) at loc(-26.65, 0.0, 90.0) on Top
  module = {temp-module}

public pcb-design VITA46-10-RTM-6U (main-module:Ref) :
  unique pcb-module temp-module :
    inst instance : {main-module}
    package(instance) at loc(0.0, 0.0) on Top
    val [dx dy] = [(10.25 - 81.5 / 2.0), (233.35 / 2.0 - 7.65)]
    unique inst h0 : {mounting-hole-cmp(1.5)}[3]
    unique inst h1 : {mounting-hole-cmp(2.325)}[3]
    package({h0}[0]) at loc(dx, dy) on Top
    package({h0}[1]) at loc(dx, dy - 84.7) on Top
    package({h0}[2]) at loc(dx, dy - 218.05) on Top
    package({h1}[0]) at loc(dx - 5.5 , dy) on Top
    package({h1}[1]) at loc(dx - 5.5 , dy - 84.7) on Top
    package({h1}[2]) at loc(dx - 5.5 , dy - 218.05) on Top
    package(instance.backplane) at loc(-35.2, 89.55, -90.0) on Top
  module = {temp-module}


public pcb-module microsemi-A2F200M3F-FGG256I :
  port src-1V5 : power
  port src-3V3 : power
  port sys-i2c : i2c[2]
  inst fpga : {microsemi/A2F200M3F-FGG256I}
  net gnd (src-1V5.gnd, src-3V3.gnd)
  for p in ports(fpga) do :
    val pin-name = to-string(p)
    if substring?(pin-name, "GND") : net (gnd, {p})
    for n in ["VCC" "VCC15A" "VCC15ADCx"] do : if substring?(pin-name, n) : net (src-1V5.vdd, {p})
    for n in ["VCC33A" "VCC33ADCx" "VCC33AP" "VCC33SDDx" "VCCMAINXTAL" "VCCLPXTAL"] do : if substring?(pin-name, n) : net (src-3V3.vdd, {p})

  net (sys-i2c[0].sda, fpga.I2C_0_SDA-GPIO[22])
  net (sys-i2c[0].scl, fpga.I2C_0_SCL-GPIO[23])
  net (sys-i2c[1].sda, fpga.I2C_1_SDA-GPIO[30])
  net (sys-i2c[1].scl, fpga.I2C_1_SCL-GPIO[31])

public pcb-module board-controller :
    port sys-i2c:i2c[2]
    inst ctrl : microsemi-A2F200M3F-FGG256I
    net (ctrl.sys-i2c sys-i2c)
    for i in 0 to 70 do :
      supports gpio :
        require p:fpga-io from ctrl.fpga
        gpio => p.io
    supports reset :
      require r:reset from ctrl.fpga
      reset => r.reset
    for i in 0 to 30 do :
      supports lvds :
        require d:fpga-diff from ctrl.fpga
        N => d.N
        P => d.P
    for i in 0 to 10 do :
      supports i2c :
        require d:fpga-io[2] from ctrl.fpga
        sda => d[0].io
        scl => d[1].io

public deftype PWL
public defmulti get (f:PWL, x:Double) -> Double

public defn PWL (ps:Tuple<[Double,Double]>) -> PWL :
  new PWL :
    defmethod get (this, x:Double) :
      val n = length(ps)
      if x < ps[0][0] :
        println("Warning: PWL is extrapolating with zero-order hold")
        ps[0][1]
      else if x >= ps[0][0] and x <= ps[n - 1][0] :
        val i = for i in 0 to n find! :
          ps[i][0] >= x
        val j = for i in reverse(0 to n) find! :
          ps[i][0] <= x
        if i == j :
          ps[i][1]
        else :
          val dydx = (ps[i][1] - ps[j][1]) / (ps[i][0] - ps[j][0])
          dydx * (x - ps[j][0]) + ps[j][1]
      else if x > ps[n - 1][0] :
        println("Warning: PWL is extrapolating with zero-order hold")
        ps[n - 1][1]
      else  :
        fatal("Something is wrong in PWL with x = %_" % [x])

; Assign schematic and layout groups
; sch-lay-grp([[inst0] [i1 i2]])

; PACKAGESPLIT

public pcb-component mounting-hole-cmp (drill-r:Double, pad-r: Double, mask-r:Double) :
  ; pin h
  package = {non-plated-hole-pkg(drill-r, mask-r)}()
  reference-prefix = "H"

public defn mounting-hole-cmp (drill-r:Double, pad-r:Double) :
  mounting-hole-cmp(drill-r, pad-r, pad-r + 0.35)

public defn mounting-hole-cmp (drill-r:Double) :
  mounting-hole-cmp(drill-r, drill-r + 0.35)

public defn board-mounting-holes (w:Double, h:Double, s:Symbol|Double) :
  inside pcb-module :
    val r = match(s) :
      (screw:Symbol) :
        switch(screw) :
          ;Loose Fit https://blogs.mentor.com/tom-hausherr/blog/tag/pcb-mounting-holes/
          `M2 : 2.3 / 2.0
          `M2p5 : 2.85 / 2.0
          `M3 : 3.5 / 2.0
          `M3p5 : 3.9 / 2.0
          else : fatal("Unsupported Screw size %_ for mounting hole" % [screw])
      (diameter:Double) : diameter / 2.0
      (f) : fatal("Unsupported call to mounting hole")
    inst holes : {mounting-hole-cmp(r)}[4]
    val offs = r * 6.0 ;1.5X bolt diameter * 2
    for (l in grid-locs(2, 2, w - offs, h - offs), i in 0 to 4) do :
      package(holes[i]) at l on Top

; This function is used to create a package mapping and box symbol from a PinSpec
defn gen-symbol-map (ps:PinSpec, pkg:Ref) :
  inside pcb-component :
    make-pins(ps)
    assign-package(pkg, ps)

defn apply-power-pin-params (v-lim:Tuple<Double>, vdd:Double) :
  inside properties:
    power-pin => true
    v-lim => v-lim
    vdd => vdd

defn apply-se-receiver-params (vi:Tuple<Double>,) :
  inside properties:
    se-receiver => true
    vi => vi

public pcb-component maxim-max1606x-cmp :
  manufacturer = "Maxim Integrated"
  mpn = "MAX16061ETP+"
  description = "1% Accurate, Quad-/Hex-/Octal-Voltage ÂµP Supervisors"
  val ps = PinSpec $ #TABLE :
    [Ref     | Int ...   | Dir]
    [in[0]   | 17 | Left]
    [in[1]   | 18 | Left]
    [in[2]   | 19 | Left]
    [in[3]   | 1  | Left]
    [in[4]   | 2  | Left]
    [in[5]   | 3  | Left]
    [WDI     | 4  | Left]
    [nMR     | 10 | Left]
    [SRT     | 11 | Left]
    [nMARGIN | 12 | Left]
    [TOL     | 20 | Left]
    [nRESET  | 16 | Right]
    [out[0]  | 15 | Right]
    [out[1]  | 14 | Right]
    [out[2]  | 13 | Right]
    [out[3]  | 7  | Right]
    [out[4]  | 8  | Right]
    [out[5]  | 9  | Right]
    [GND     | 5  | Down]
    [PAD     | 21  | Down]
    [VCC     | 6  | Up]
  gen-symbol-map(ps, qfn-package(0.5, 4.0, 20, 0.25, 0.55, [2.1, 2.1]))

public pcb-component idt-5PB11xx-cmp (n:Int) :
  description = "1.8V to 3.3V LVCMOS High Performance Clock Buffer Family"
  manufacturer = "IDT"
  val [code clkin-p en-p out-p vdd-p gnd-p pkg] = switch(n) :
    2  : ["02PGG" 1 2 [3, 8                               ] [6           ] [4           ] sop65-package(8) ] 
    4  : ["04PGG" 1 2 [3, 8, 5, 7                         ] [6           ] [4           ] sop65-package(8) ] 
    6  : ["06PGG" 1 2 [3, 14, 11, 13, 6, 9                ] [5, 8, 12    ] [4, 7, 10    ] sop65-package(14)] 
    8  : ["08PGG" 1 2 [3, 16, 13, 15, 6, 11, 8, 9         ] [5, 10, 14   ] [4, 7, 12    ] sop65-package(16)] 
    10 : ["10PGG" 1 2 [3, 20, 17, 19, 6, 15, 8, 13, 12, 10] [5, 9, 14, 18] [4, 7, 11, 16] sop65-package(20)]
    else : fatal("Incorrect number of channels for idt-5PB11x %_" % [n])
  mpn = to-string("5PB11%_" % [code])

  val ps = PinSpec $ #TABLE :
    [Ref    | Int ...   | Dir]
    [clkin  | clkin-p | Left]
    [en  | en-p    | Left]
    [vdd | vdd-p | Up]
    [gnd | gnd-p | Down]
    for (p in out-p, i in 0 to false) do :
      [clkout[i] | p | Right]
  gen-symbol-map(ps, pkg)

  ; TODO: inherit vdd parameter from vdd pin. Want to set externally
  val vdd-v = 1.8
  properties(vdd):
    apply-power-pin-params([1.71, 3.465], vdd-v)
  properties(clkin):
    apply-se-receiver-params([0.3 * vdd-v, 0.7 * vdd-v])

public pcb-module idt-5PB11xx (n:Int) :
  port src : power
  pin clkin
  port clkout : pin[n]
  inst buffer : {idt-5PB11xx-cmp(n)}
  default-bypass(buffer)
  net (buffer.clkin, clkin)
  ; net (buffer.clkout, clkout)


public pcb-module vpx-6u :
  port vpx-power : power[6]
  port vpx-pairs : diff-pair[6][32]
  port vpx-sig : pin[6][8]
  port P0-sig : pin[16]
  port P0-pairs : diff-pair[4]
  pin gnd
  inst P0 : te-connectivity/te-2102772-1
  inst P : te-connectivity/te-2102771-1[6]
  package(P[0]) at loc(0.0, 0.0) on Top
  package(P[1]) at loc(28.8, 0.0) on Top
  package(P0) at loc(21.73 + 28.8, 0.0) on Top
  for i in 2 to 6 do : package(P[i]) at loc(to-double(i + 1) * 28.8, 0.0) on Top

  properties(vpx-pairs) :
    external => true

  defn vpx-map (r:Int, c:Int, con:Int) :
    val name = Ref(red-alph-letter(r))[c + 1]
    if c % 2 == 1 :
      if r % 3 == 1 :
        net (P[con].{name}, vpx-pairs[con][2 * c + (r / 3)].P)
      else if r % 3 == 2 :
        net (P[con].{name}, vpx-pairs[con][2 * c + (r / 3)].N)
      else :
        net (P[con].{name}, gnd)
    else :
      if r == 6 :
        if c % 2 == 0 :
          net (P[con].{name}, vpx-sig[con][c / 2])
      else :
        if r % 3 == 0 :
          net (P[con].{name}, vpx-pairs[con][2 * c + (r / 3)].P)
        else if r % 3 == 1 :
          net (P[con].{name}, vpx-pairs[con][2 * c + (r / 3)].N)
        else :
          net (P[con].{name}, gnd)
    []

  for i in 0 to 6 do :
    for c in 0 to 16 do :
      for r in 0 to 7 do :
        vpx-map(r,c,i)

  val sig-seq = to-seq(0 to 16)

  defn P0-map (r:Int, c:Int) :
    val name = Ref(red-alph-letter(r))[c + 1]
    if c < 3 :
      if r % 4 == 0 :
        net (vpx-power[2 * c + (r / 4)].vdd, P0.{name})
        net (vpx-power[2 * c + (r / 4)].gnd, gnd)
      if r % 4 == 1 :
        net (vpx-power[2 * c + (r / 4)].vdd, P0.{name})
      if r % 4 == 2 :
        net (vpx-power[2 * c + (r / 4)].vdd, P0.{name})
    else if c < 6 : 
      if (r == 2 or r == 4) :
        net (P0.{name}, gnd)
      else :
        net (P0.{name}, P0-sig[next(sig-seq)])
    else if c == 6 :
      if r == 6 :
        net (P0.{name}, P0-sig[next(sig-seq)])
      else :
        if r % 3 == 0 :
          net (P0.{name}, P0-pairs[0 + (r / 3)].P)
        else if r % 3 == 1 :
          net (P0.{name}, P0-pairs[0 + (r / 3)].N)
        else :
          net (P0.{name}, gnd) 
    else if c == 7 :
      if r % 3 == 1 :
        net (P0.{name}, P0-pairs[2 + (r / 3)].P)
      else if r % 3 == 2 :
        net (P0.{name}, P0-pairs[2 + (r / 3)].N)
      else :
        net (P0.{name}, gnd)
    []

  for c in 0 to 8 do :
    for r in 0 to 7 do :
      P0-map(r,c)

  for i in 0 to 6 do :
    for j in 0 to 32 do :
      supports lvds :
        N => vpx-pairs[i][j].N
        P => vpx-pairs[i][j].P

  for i in 0 to 6 do :
    for j in 0 to 8 do :
      supports gpio :
        gpio => vpx-sig[i][j]
